import java.util.*;
import java.util.stream.Collectors;
import lombok.Getter;
import lombok.Setter;
@Getter
@Setter
public class Problem { // HOMEWORK
      private List<Destination> destinations;
      private List<Person> listOfPersons;

    public Problem(List<Destination> destinations, List<Person> listOfPersons) {
        this.destinations = destinations;
        this.listOfPersons = listOfPersons;
    }

    public void printDestinationsPassed(List<Person> listOfPersons) {

        List<Destination> listOfDestinations = listOfPersons.stream()
                .map(Person::getDestination)
                .distinct()
                .toList();
        listOfDestinations.forEach(System.out::println);
    }
    public void printDestinationsMap(List<Person> listOfPersons)
    {
        Map<Destination, List<Person>> destinationsMap = listOfPersons.stream()
                .collect(Collectors.groupingBy(Person::getDestination));
        for (Map.Entry<Destination, List<Person>> entry : destinationsMap.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
    }

    /**
     * Greedy algorithm will separate the list of Persons in two lists - Drivers and Passengers
     * and will iterate through drivers List and for each driver, the program will try to match for it
     * with a passenger having the same destination. The drivers remaining with no other passengers, won't
     * affect the algorithm
     * @param listOfPersons A list with all Persons generated by the third-party-library
     */
    public void greedyMatching(List<Person> listOfPersons)
    {
        ArrayList<Driver> drivers = listOfPersons.stream()
                .filter(person -> person instanceof Driver)
                .map(person -> (Driver) person)
                .collect(Collectors.toCollection(ArrayList::new));

        ArrayList<Passenger> passengers = listOfPersons.stream()
                .filter(person -> person instanceof Passenger)
                .map(person -> (Passenger) person)
                .collect(Collectors.toCollection(ArrayList::new));
        System.out.println("\nDestinations matching: ");
            for (Driver driver : drivers) {
                for (Passenger passenger : passengers) {
                if (passenger.getDestination().equals(driver.getDestination())) {
                    System.out.println(STR."Driver \{driver.getName()} is matched with passenger \{passenger.getName()}");
                    passengers.remove(passenger); // After finding a passenger who has the same destination with driver, will be removed from List
                    driver.setPassenger(passenger); // The program will set a passenger for this driver
                    break; // A passenger was founded to match with a driver with the same destination, so this search will be stopped
                }
            }
        }
    }

    @Override
    public String toString() {
        return STR."Problem{destinations=\{destinations}, listOfPersons=\{listOfPersons}\{'}'}";
    }
}
